import sys
import os
sys.path.append(os.path.dirname(__file__))  # add current folder to sys.path
from flask import Flask, request, jsonify
from fully_automated import run_delivery_script   # Your main delivery script
import logging
import traceback
from threading import Thread
import boto3
from flask_cors import CORS
import time
from datetime import datetime, timedelta
from delivary_route_plan import run_main_program
from whatsapp import process_and_send_routes
from customer_report import get_delivery_data 
import uuid

def normalize_date_to_string(date_obj):
    '''Convert various date formats to YYYY-MM-DD string'''
    if date_obj is None:
        return None
    if isinstance(date_obj, str):
        return date_obj[:10]
    if hasattr(date_obj, 'strftime'):
        return date_obj.strftime('%Y-%m-%d')
    return str(date_obj)[:10]

# ---------------- Flask Setup ----------------
app = Flask(__name__)
CORS(app)  # Enable CORS for all origins (good for testing)

# Configure logging (writes to both console & file)
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s [%(levelname)s] %(message)s",
    handlers=[
        logging.FileHandler("api_server.log"),
        logging.StreamHandler()
    ]
)

# ---------------- API Key ----------------
API_KEY = "mysecretkey123"  # move to environment variable in production

# ---------------- S3 Setup ----------------
S3_BUCKET = "delivery-route-plans"
S3_REGION = "ap-south-1"
s3 = boto3.client("s3", region_name=S3_REGION)

# ---------------- Expected Files ----------------
FILES = [
    "map_links_breakfast.html",
    "map_links_lunch.html",
    "map_links_dinner.html",
    "route_plan_breakfast.txt",
    "route_plan_lunch.txt",
    "route_plan_dinner.txt",
]

tasks = {}
# ---------------- Helper Functions ----------------
def run_main_program_background(request_id, num_drivers, date_filter=None, exec_filter=None, session_filter=None):
    """Run run_main_program and store result in tasks dict"""
    try:
        tasks[request_id] = {"status": "processing", "result": None}

        result = run_main_program(num_drivers=num_drivers, delivery_date=date_filter)

        # Convert datetime to ISO string
        for session_key, records in result.items():
            for rec in records:
                if 'Date' in rec:
                    rec['Date'] = normalize_date_to_string(rec['Date'])

        # Apply optional filters
        if date_filter:
            filter_date_str = normalize_date_to_string(date_filter)
            for key in result:
                result[key] = [
                    r for r in result[key]
                    if normalize_date_to_string(r.get("Date")) == filter_date_str
                ]

        else:
            # pick the next date available in the data
            all_dates = sorted({normalize_date_to_string(r.get("Date")) for records in result.values() for r in records if r.get("Date")})
            if all_dates:
                next_date = all_dates[0]
                for key in result:
                    result[key] = [r for r in result[key] if normalize_date_to_string(r.get("Date")) == next_date]


        if exec_filter:
            for key in result:
                result[key] = [
                    r for r in result[key]
                    if r.get("Executive") is not None and exec_filter.lower() 
        in r.get("Executive").lower()
                ]

        if session_filter:
            key = session_filter.lower()
            result = {key: result.get(key, [])}

        tasks[request_id] = {"status": "completed", "result": result}

    except Exception as e:
        import traceback
        tasks[request_id] = {
            "status": "failed",
            "error": traceback.format_exc()
        }

def run_script_async():
    auth_header = request.headers.get("Authorization")
    if auth_header != f"Bearer {API_KEY}":
        return jsonify({"error": "Unauthorized"}), 401

    data = request.get_json(silent=True) or {}
    
def run_script_in_background():
    """Run the delivery script in a separate thread to prevent blocking the API"""
    try:
        logging.info("Background thread started: running delivery script...")
        run_delivery_script()
        logging.info("Background thread completed successfully.")
    except Exception as e:
        logging.error(f"Error in background thread: {str(e)}")
        logging.error(traceback.format_exc())

def generate_presigned_url(filename, expires=3600):
    """Generate a presigned URL for S3 file"""
    return s3.generate_presigned_url(
        "get_object",
        Params={"Bucket": S3_BUCKET, "Key": filename},
        ExpiresIn=expires
    )

def check_file_exists_s3(filename):
    """Check if a file exists in S3"""
    try:
        s3.head_object(Bucket=S3_BUCKET, Key=filename)
        return True
    except s3.exceptions.ClientError:
        return False

# ---------------- Routes ----------------
@app.route("/delivery_data", methods=["GET"])
def deliveries():
    try:
        # Read query params from URL
        filters = {
            "delivery_date": request.args.get("delivery_date"),
            "session": request.args.get("session"),
            "first_name": request.args.get("first_name"),
            "last_name": request.args.get("last_name"),
            "street": request.args.get("street"),
            "status": request.args.get("status"),
            "whatsapp_number": request.args.get("whatsapp_number"),
            "quantity": request.args.get("quantity")
        }

        # Call your DB function
        data = get_delivery_data(**filters)

        return jsonify({"count": len(data), "data": data}), 200

    except Exception as e:
        return jsonify({"error": str(e)}), 500


@app.route("/trigger", methods=["POST"])
def trigger():
    """Trigger delivery script and return presigned URLs in frontend-friendly format"""
    auth_header = request.headers.get("Authorization")
    if not auth_header or auth_header != f"Bearer {API_KEY}":
        logging.warning("Unauthorized access attempt")
        return jsonify({"success": False, "message": "Unauthorized"}), 401

    try:
        # Generate a unique request ID (based on timestamp)
        request_id = f"rp-{int(time.time() * 1000)}"

        # Start the delivery script in the background
        thread = Thread(target=run_script_in_background)
        thread.start()
        logging.info(f"Delivery script triggered successfully (background), requestId: {request_id}")

        # Generate presigned URLs for all expected files + ready status
        files_data = []
        for f in FILES:
            try:
                url = generate_presigned_url(f)
                ready = check_file_exists_s3(f)
                files_data.append({
                    "file": f,
                    "url": url,
                    "ready": ready
                })
            except Exception as e:
                logging.error(f"Could not generate presigned URL for {f}: {e}")

        return jsonify({
            "success": True,
            "message": "Route planning initiated successfully",
            "timestamp": datetime.utcnow().isoformat() + "Z",
            "data": {
                "status": "initiated",
                "requestId": request_id,
                "estimatedCompletion": "5 minutes",
                "files": files_data
            }
        }), 200

    except Exception as e:
        logging.error(f"Error while triggering script: {str(e)}")
        logging.error(traceback.format_exc())
        return jsonify({"success": False, "message": str(e)}), 500


@app.route("/run-script1", methods=["POST"])
def run_script1():
    auth_header = request.headers.get("Authorization")
    if auth_header != f"Bearer {API_KEY}":
        return jsonify({"error": "Unauthorized"}), 401

    data = request.get_json(silent=True) or {}
    num_drivers = data.get("num_drivers")

    logging.info(f"Running main program with num_drivers={num_drivers}")
    result = run_main_program2(num_drivers=num_drivers)

    # After execution, generate presigned URLs for expected files
    files_data = []
    for f in FILES:
        try:
            url = generate_presigned_url(f)
            ready = check_file_exists_s3(f)
            files_data.append({
                "file": f,
                "url": url,
                "ready": ready
            })
        except Exception as e:
            logging.error(f"Could not generate presigned URL for {f}: {e}")

    return jsonify({
        "success": True,
        "message": "Program executed successfully",
        "timestamp": datetime.utcnow().isoformat() + "Z",
        "data": {
            "status": "completed",
            "requestId": f"rs-{int(time.time() * 1000)}",
            "executiveCount": num_drivers,
            "files": files_data,
            "executionResult": result
        }
    })
    
@app.route("/run-script", methods=["POST"])
def run_script_async():
    auth_header = request.headers.get("Authorization")
    if auth_header != f"Bearer {API_KEY}":
        return jsonify({"error": "Unauthorized"}), 401

    data = request.get_json(silent=True) or {}
    num_drivers = int(data.get("num_drivers", 1))
    date_str = data.get("date")
    if date_str:
        date_filter = normalize_date_to_string(date_str)
    else:
        date_filter = (datetime.utcnow().date() + timedelta(days=1)).isoformat()
    exec_filter = data.get("executive")
    session_filter = data.get("session")

    request_id = str(uuid.uuid4())
    thread = Thread(target=run_main_program_background, args=(request_id, num_drivers, date_filter, exec_filter, session_filter))
    thread.start()

    return jsonify({
        "success": True,
        "status": "processing",
        "requestId": request_id,
        "message": "Program started in background. Poll /status/<requestId> for updates."
    }), 202

# New endpoint to check status
@app.route("/status/<request_id>", methods=["GET"])
def check_status(request_id):
    task = tasks.get(request_id)
    if not task:
        return jsonify({"success": False, "message": "Invalid requestId"}), 404

    response = {
        "success": True,
        "status": task.get("status")
    }
    if task.get("status") == "failed":
        # Include the error message
        response["error"] = task.get("error")
    else:
        response["result"] = task.get("result")

    return jsonify(response)


@app.route("/send_routes", methods=["POST"])
def send_routes():
    """Trigger sending merged routes via WhatsApp and return JSON results
    auth_header = request.headers.get("Authorization")
    if auth_header != f"Bearer {API_KEY}":
        return jsonify({"success": False, "message": "Unauthorized"}), 401

    try:
        # Call your WhatsApp route processor
        result = process_and_send_routes()
        return jsonify({"success": True, "data": result})
    except Exception as e:
        logging.error(f"Error in sending routes: {e}")
        logging.error(traceback.format_exc())
        return jsonify({"success": False, "message": str(e)}), 500 """


@app.route("/", methods=["GET"])
def home():
    """Basic health check"""
    return jsonify({
        "message": "Route Optimization API is running ðŸš€",
        "endpoints": {
            "POST /trigger": "Run delivery optimization script (requires Bearer token)"
        }
    })

# ---------------- Run Server ----------------
if __name__ == "__main__":
    # Bind to all interfaces, debug mode OFF for production
    app.run(host="0.0.0.0", port=5001, debug=False, use_reloader=False)
